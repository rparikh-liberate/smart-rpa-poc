/**
 * Workflow Recorder Tool
 * 
 * This tool helps the LLM create reusable semantic workflows by:
 * 1. Observing actions taken during a session
 * 2. Converting refs to semantic descriptions (role + name)
 * 3. Generating a workflow JSON file
 * 
 * Usage:
 * 1. Start recording: workflow_record_start("workflow-name")
 * 2. Perform actions normally (navigate, click, type, etc.)
 * 3. Stop recording: workflow_record_stop()
 * 4. The workflow is saved to workflows/workflow-name.json
 */

import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';

class WorkflowRecorder {
  constructor() {
    this.recording = false;
    this.workflowName = null;
    this.steps = [];
    this.currentSnapshot = null;
  }

  startRecording(name) {
    this.recording = true;
    this.workflowName = name;
    this.steps = [];
    console.error(`ðŸ“¹ Started recording workflow: ${name}`);
  }

  stopRecording() {
    this.recording = false;
    console.error(`â¹ï¸  Stopped recording workflow: ${this.workflowName}`);
    return this.generateWorkflow();
  }

  isRecording() {
    return this.recording;
  }

  // Called when browser_navigate is executed
  recordNavigate(url) {
    if (!this.recording) return;
    
    this.steps.push({
      step: this.steps.length + 1,
      action: 'navigate',
      url,
      description: `Navigate to ${url}`
    });
  }

  // Called when browser_snapshot is executed
  recordSnapshot(snapshotText) {
    if (!this.recording) return;
    
    this.currentSnapshot = snapshotText;
    
    // Only record explicit snapshots (not auto-snapshots after actions)
    // this.steps.push({
    //   step: this.steps.length + 1,
    //   action: 'snapshot',
    //   description: 'Take page snapshot'
    // });
  }

  // Called when browser_click is executed
  recordClick(element, ref) {
    if (!this.recording) return;
    
    const semantic = this.refToSemantic(ref);
    
    this.steps.push({
      step: this.steps.length + 1,
      action: 'click',
      target: {
        role: semantic.role,
        name: semantic.name,
        name_contains: this.extractKeywords(semantic.name),
        description: element
      },
      description: `Click ${element}`
    });
  }

  // Called when browser_type is executed
  recordType(element, ref, text, submit) {
    if (!this.recording) return;
    
    const semantic = this.refToSemantic(ref);
    
    this.steps.push({
      step: this.steps.length + 1,
      action: 'type',
      target: {
        role: semantic.role,
        name: semantic.name,
        name_contains: this.extractKeywords(semantic.name),
        description: element
      },
      value: text,
      submit: submit || false,
      description: `Type "${text}" into ${element}`
    });
  }

  // Called when browser_select_option is executed
  recordSelectOption(element, ref, values) {
    if (!this.recording) return;
    
    const semantic = this.refToSemantic(ref);
    
    this.steps.push({
      step: this.steps.length + 1,
      action: 'select_option',
      target: {
        role: semantic.role,
        name: semantic.name,
        name_contains: this.extractKeywords(semantic.name),
        description: element
      },
      option: values[0],
      description: `Select "${values[0]}" in ${element}`
    });
  }

  // Convert a ref to semantic description using the current snapshot
  refToSemantic(ref) {
    if (!this.currentSnapshot) {
      return { role: 'unknown', name: '' };
    }

    // Parse snapshot to find the ref
    // Format: "- role \"name\" [ref=eXXX]"
    const lines = this.currentSnapshot.split('\n');
    for (const line of lines) {
      if (line.includes(`[ref=${ref}]`)) {
        // Extract role and name
        const match = line.match(/- (\w+)(?:\s+"([^"]*)")?\s+\[ref=/);
        if (match) {
          return {
            role: match[1],
            name: match[2] || ''
          };
        }
      }
    }

    return { role: 'unknown', name: '' };
  }

  // Extract keywords from element name for matching
  extractKeywords(name) {
    if (!name) return '';
    
    // Remove common words and get the main keyword
    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at'];
    const words = name.toLowerCase().split(/\s+/);
    const filtered = words.filter(w => !stopWords.includes(w) && w.length > 2);
    
    return filtered[0] || name.toLowerCase();
  }

  generateWorkflow() {
    const workflow = {
      name: this.workflowName,
      version: '2.0',
      description: `Auto-generated workflow: ${this.workflowName}`,
      steps: this.steps,
      success_criteria: [
        'Workflow completes without errors',
        'All steps execute successfully'
      ],
      notes: [
        'This workflow was auto-generated by workflow recorder',
        'Uses semantic selectors (role, name patterns) instead of refs',
        'Should be deterministic across sessions',
        'Review and adjust target selectors as needed'
      ]
    };

    return workflow;
  }

  async saveWorkflow(workflowsDir) {
    const workflow = this.generateWorkflow();
    const filePath = join(workflowsDir, `${this.workflowName}.json`);
    
    await writeFile(filePath, JSON.stringify(workflow, null, 2));
    console.error(`ðŸ’¾ Saved workflow to: ${filePath}`);
    
    return filePath;
  }
}

// Singleton instance
const recorder = new WorkflowRecorder();

export {
  recorder,
  WorkflowRecorder
};



